*select.txt* Fuzzy select file/buffer/MRU/etc

Author:  Maxim Kim <https://habamax.github.io>
URL:     https://github.com/habamax/vim-select
License: MIT

INTRODUCTION                                                          *select*

Plugin works with recent (nightly) vim having |matchfuzzypos| function and
|prompt-buffer| feature implemented.

For buffers, MRU and commands it lets you narrow down the list with fuzzy
matching and select with <CR> or <Tab> if only 1 candidate is in the list.

For files it will let you go to parent directory with <BS> and to selected
directory with <CR>.

Project wide file search uses either `ripgrep` or `fd` tool so be sure you have
one of them installed on your system. By default it uses vim current working
directory as a project root.



MAPPINGS                                                     *select-mappings*

There are no default global mappings, add your own.

Safe (will not create mappings if plugin was not loaded):

>
    " add it to ~/.vim/after/plugin/select.vim
    if exists("g:loaded_select")
        nmap <leader>fo <Plug>(SelectFile)
        nmap <leader>ff <Plug>(SelectProjectFile)
        nmap <leader>fp <Plug>(SelectProject)
        nmap <leader>b <Plug>(SelectBuffer)
        nmap <leader>m <Plug>(SelectMRU)
        nmap <leader>; <Plug>(SelectCmd)
    endif

or regular:
>
    nmap <leader>fo <Plug>(SelectFile)
    nmap <leader>ff <Plug>(SelectProjectFile)
    nmap <leader>fp <Plug>(SelectProject)
    nmap <leader>b <Plug>(SelectBuffer)
    nmap <leader>m <Plug>(SelectMRU)
    nmap <leader>; <Plug>(SelectCmd)


DEFAULT SELECT WINDOW MAPPINGS                       *select-default-mappings*

<ESC> to close the select window.                               *select-<ESC>*

<CR> to open/execute current item.                               *select-<CR>*

<S-CR> or <C-s> to open current item in split.    *select_<C-s>* *select_<S-CR>*

<C-v> to open current item in vertical split.                   *select_<C-v>*

<C-t> to open current item in a tab.                            *select_<C-v>*

                                                                *select-<TAB>*
<TAB> select next item in the list, for a single item it will open/execute it.

<BS> open parent directory. Only for |SelectFile|.              *select-<BS>*

<C-n> or <Down> select next item.                               *select-<C-n>*

<C-p> or <Up> select previous item.                             *select-<C-p>*

<PageUp> scroll up select window.                            *select-<PageUp>*

<PageDown> scroll down select window.                      *select-<PageDown>*



COMMANDS                                                     *select-commands*

:Select                                                              *:Select*

Select file from current file directory.


:Select file <dir>                                              *:Select_file*

Select file from current file directory.
Accepts directory as an argument.


:Select projectfile <dir>                                *:Select_projectfile*

Select project file from current working directory(and sub-directories).
Accepts directory as an argument.

NOTE: only works if ripgrep or fd is installed.


:Select project                                              *:Select_project*

Select project from the list of projects and run |:Select_projectfile| on
it. Each project is a current working directory where |:Select_projectfile|
was run and a file was selected.

The list of projects is persisted in `~/.vim/.selectprojects` or
`~/.selectprojects` file.



:Select buffer                                                *:Select_buffer*

Select buffer from buffer list.


:Select mru                                                      *:Select_mru*

Select file from |v:oldfiles| AKA Most Recently Used.


:Select help                                                    *:Select_help*

Select help tag and show relevant help topic.

NOTE: Only work if `ripgrep` is installed.


:Select command                                              *:Select_command*

Select :ex command and execute it.


:Select colors                                                *:Select_colors*

Select colorscheme and apply it.



EXTENDING                                                   *select_extending*

First of all create an "extension point":

>
    let g:select_info = {}

And then...


BASIC EXAMPLE

Let's select something from the list and echo it in vim:

>
    let g:select_info.test = {}
    let g:select_info.test.data = {-> ['hello', 'from', 'vim-select', 'plugin']}
    let g:select_info.test.sink = "echomsg '%s'"

Then with the command `:Select test` you can select a value from the list and
see it was echoed as a vim message.

`%s` would be substituted with the selected value in the `sink` string
parameter.

You can also provide a dict with action there, like:

>
    func! ShowMessage(msg) abort
        echom a:msg
    endfunc

    let g:select_info.test = {}
    let g:select_info.test.data = {-> ['hello', 'from', 'vim-select', 'plugin']}
    let g:select_info.test.sink = {"action": {v -> ShowMessage(v)}}


SHOW HIGHLIGHT GROUP
>
    let g:select_info.highlight = {}
    let g:select_info.highlight.data = {-> getcompletion('', 'highlight')}
    let g:select_info.highlight.sink = "hi %s"

Then use `:Select highlight` to select and show syntax highlight group
parameters.


LOADING SESSIONS

Imagine you have all your sessions saved in `~/.vimdata/sessions` folder.
I do have them there and usually create session with a helper command:

>
    command! -nargs=1 S :mksession! ~/.vimdata/sessions/<args>

Then just a simple `:S my_another_project` to persist a session.

Now to narrow down and source/apply a session you can setup select plugin with:

>
    let g:select_info.session = {}
    let g:select_info.session.data = {-> map(glob("~/.vimdata/sessions/*", 1, 1), {_, v -> fnamemodify(v, ":t")})}
    let g:select_info.session.sink = "%%bd | source ~/.vimdata/sessions/%s"
    nnoremap <leader>fs :Select session<CR>


PLAY MUSIC

Funny thing, vim can play mp3s, so just for fun we can select a music file and
play it:

>
    let g:select_info.sound = {}
    let g:select_info.sound.data = {"cmd": "rg --files --glob *.mp3"}
    let g:select_info.sound.sink = {"transform": {p, v -> p..v}, "action": {v -> sound_playfile(v)}}

Having this you can `:Select sound ~/Music`, select and play mp3 file.

A new key `"transform"` is to apply additional logic for a value to be passed
for an action. It receives a current working directory path and a selected value.
In this example the value is transformed to be a full path to a mp3 file.


FILETYPE SPECIFIC EXAMPLE

There is `b:select_info` you can use in the same way as `g:select_info`.

For example I would like to be able to select and run Godot
(https://godotengine.org/) scene and it should only be availble in
gdscript (https://github.com/habamax/vim-godot) files.

Just add to `~/.vim/after/ftplugin/gdscript.vim`:

>
    let b:select_info = {"godotscene": {}}
    let b:select_info.godotscene.data = {"cmd": "rg --files --glob *.tscn"}
    let b:select_info.godotscene.sink = {"transform": {_, v -> fnameescape(v)}, "action": "GodotRun %s"}
    nnoremap <buffer> <leader><leader>f :Select godotscene<CR>
